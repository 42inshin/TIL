(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{409:function(_,v,t){"use strict";t.r(v);var r=t(45),a=Object(r.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"_2020-12-07-월"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2020-12-07-월"}},[_._v("#")]),_._v(" 2020-12-07(월)")]),_._v(" "),t("h2",{attrs:{id:"_1-학습-날짜"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-학습-날짜"}},[_._v("#")]),_._v(" 1. 학습 날짜")]),_._v(" "),t("ul",[t("li",[_._v("2020-12-07(월)\n"),t("br")])]),_._v(" "),t("h2",{attrs:{id:"_2-학습-시간"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-학습-시간"}},[_._v("#")]),_._v(" 2. 학습 시간")]),_._v(" "),t("ul",[t("li",[_._v("05:00 ~ 08:00 (집)")]),_._v(" "),t("li",[_._v("10:00 ~ 11:45 (집)\n"),t("br")])]),_._v(" "),t("h2",{attrs:{id:"_3-학습-범위-및-주제"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-학습-범위-및-주제"}},[_._v("#")]),_._v(" 3. 학습 범위 및 주제")]),_._v(" "),t("ul",[t("li",[_._v("cs50 강의 시청\n"),t("br")])]),_._v(" "),t("h2",{attrs:{id:"_4-동료-학습-방법"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-동료-학습-방법"}},[_._v("#")]),_._v(" 4. 동료 학습 방법")]),_._v(" "),t("ul",[t("li",[_._v("해당사항없음.\n"),t("br")])]),_._v(" "),t("h2",{attrs:{id:"_5-학습-목표"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-학습-목표"}},[_._v("#")]),_._v(" 5. 학습 목표")]),_._v(" "),t("ul",[t("li",[_._v("기존의 c언어 학습의 기초적인 틀을 닦아보자!\n"),t("br")])]),_._v(" "),t("h2",{attrs:{id:"_6-상세-학습-내용"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-상세-학습-내용"}},[_._v("#")]),_._v(" 6. 상세 학습 내용")]),_._v(" "),t("blockquote",[t("p",[_._v("실제 코딩 시간 : 총 0시간.")])]),_._v(" "),t("h3",{attrs:{id:"메모리"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#메모리"}},[_._v("#")]),_._v(" 메모리")]),_._v(" "),t("p",[_._v(": RAM 이라는 물리적 칩이 메모리 역할을 하며, 배열의 경우 연달아서 메모리가 할당된다.")]),_._v(" "),t("ul",[t("li",[_._v("bool: 불리언, 1바이트")]),_._v(" "),t("li",[_._v("char: 문자, 1바이트")]),_._v(" "),t("li",[_._v("int: 정수, 4바이트")]),_._v(" "),t("li",[_._v("float: 실수, 4바이트")]),_._v(" "),t("li",[_._v("long: (더 큰) 정수, 8바이트")]),_._v(" "),t("li",[_._v("double: (더 큰) 실수, 8바이트")]),_._v(" "),t("li",[_._v("string: 문자열, ?바이트")])]),_._v(" "),t("h3",{attrs:{id:"검색-알고리즘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#검색-알고리즘"}},[_._v("#")]),_._v(" 검색 알고리즘")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("선형 검색"),t("br"),_._v(" : 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지를 검사.  자료가 정렬되어 있지 않거나 그 어떤 정보도 없어 하나씩 찾아야 하는 경우에 유용하다.")])]),_._v(" "),t("li",[t("p",[_._v("이진 검색"),t("br"),_._v(" : 만약 배열이 정렬되어 있다면, 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은(작은 값이 저장되어 있는) 인덱스 또는 큰 (큰 값이 저장되어 있는) 인덱스로 이동을 반복한다.")])]),_._v(" "),t("li",[t("p",[_._v("생각해보기"),t("br"),_._v("\n: 정렬이 되어있는 경우 이진 검색이 빠를 경우가 많으나, 정렬이 안되어 있는 경우에는 두가지 방법에 어떤것이 빠를지 판단하기 어렵다.")])])]),_._v(" "),t("h3",{attrs:{id:"알고리즘-표기법"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#알고리즘-표기법"}},[_._v("#")]),_._v(" 알고리즘 표기법")]),_._v(" "),t("p",[_._v("-Big O"),t("br"),_._v("\n: 실행 시간의 상한 (최악의 경우)")]),_._v(" "),t("ul",[t("li",[_._v("O(n^2) - 버블정렬, 선택정렬")]),_._v(" "),t("li",[_._v("O(n log n) - 병합 정렬")]),_._v(" "),t("li",[_._v("O(n) - 선형 검색")]),_._v(" "),t("li",[_._v("O(log n) - 이진 검색")]),_._v(" "),t("li",[_._v("O(1)\n-Big Ω"),t("br"),_._v("\n:실행 시간의 하한 (최선의 경우)")]),_._v(" "),t("li",[_._v("Ω(n^2) - 선택정렬")]),_._v(" "),t("li",[_._v("Ω(n log n) - 병합 정렬")]),_._v(" "),t("li",[_._v("Ω(n) - 버블정렬, 배열 안에 존재하는 값의 개수 세기")]),_._v(" "),t("li",[_._v("Ω(log n)")]),_._v(" "),t("li",[_._v("Ω(1) - 선형 검색, 이진 검색\n"),t("br")])]),_._v(" "),t("h1",{attrs:{id:"정렬-알고리즘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#정렬-알고리즘"}},[_._v("#")]),_._v(" 정렬 알고리즘")]),_._v(" "),t("ul",[t("li",[_._v("버블정렬"),t("br"),_._v("\n: 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬")]),_._v(" "),t("li",[_._v("선택정렬"),t("br"),_._v("\n: 배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식의 정렬")]),_._v(" "),t("li",[_._v("병합정렬"),t("br"),_._v("\n: 원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식. 반으로 나누는데 "),t("code",[_._v("O(log n)")]),_._v("의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는데 각각 "),t("code",[_._v("O(n)")]),_._v(" 시간이 걸리므로 상한 "),t("code",[_._v("O(n log n)")]),_._v(" 하한 역시 "),t("code",[_._v("Ω(n log n)")]),_._v("이다\n"),t("br")])]),_._v(" "),t("h2",{attrs:{id:"_7-학습-내용에-대한-개인적인-총평"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-학습-내용에-대한-개인적인-총평"}},[_._v("#")]),_._v(" 7. 학습 내용에 대한 개인적인 총평")]),_._v(" "),t("ul",[t("li",[_._v("기존에 잘 알지 못했던 알고리즘에 대해 제대로 학습할 수 있었던 시간이었다. Big O, Big Ω 에 대해선 전혀 알지 못했던 부분인데 알고리즘을 정리하면서 실행시간의 상한과 하한에 대해서 이해할 수 있었다.")]),_._v(" "),t("li",[_._v("알고리즘을 구현할때 각각의 방법에 따른 실행시간이 달라지는 부분을 이제는 확실하게 알수 있을 것 같다. 아직까지도 프로그래밍에 모르는 것이 많지만 지금처럼 계속해서 학습을 진행하다 보면 길이 보이지 않을까 생각해본다.\n"),t("br")])]),_._v(" "),t("h2",{attrs:{id:"_8-다음-학습-계획"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-다음-학습-계획"}},[_._v("#")]),_._v(" 8. 다음 학습 계획")]),_._v(" "),t("ul",[t("li",[_._v("GNL 구현.")]),_._v(" "),t("li",[_._v("printf 구현 방법에 대한 학습.")]),_._v(" "),t("li",[_._v("INNO-CON 시청.\n"),t("br")])]),_._v(" "),t("h2",{attrs:{id:"_9-참고-링크"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-참고-링크"}},[_._v("#")]),_._v(" 9. 참고 링크")]),_._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://www.edwith.org/boostcourse-cs-050/lecture/119026/",target:"_blank",rel:"noopener noreferrer"}},[_._v("병합 정렬"),t("OutboundLink")],1),_._v(" "),t("br")])])])}),[],!1,null,null,null);v.default=a.exports}}]);