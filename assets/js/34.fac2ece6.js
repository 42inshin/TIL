(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{389:function(t,s,a){"use strict";a.r(s);var e=a(45),_=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_2020-11-09-월"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2020-11-09-월"}},[t._v("#")]),t._v(" 2020-11-09(월)")]),t._v(" "),a("h2",{attrs:{id:"_1-학습-날짜"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-학습-날짜"}},[t._v("#")]),t._v(" 1. 학습 날짜")]),t._v(" "),a("ul",[a("li",[t._v("2020-11-09(월)\n"),a("br")])]),t._v(" "),a("h2",{attrs:{id:"_2-학습-시간"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-학습-시간"}},[t._v("#")]),t._v(" 2. 학습 시간")]),t._v(" "),a("ul",[a("li",[t._v("12:00 ~18:00 (집)\n"),a("br")])]),t._v(" "),a("h2",{attrs:{id:"_3-학습-범위-및-주제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-학습-범위-및-주제"}},[t._v("#")]),t._v(" 3. 학습 범위 및 주제")]),t._v(" "),a("ul",[a("li",[t._v("libft 함수 정리")]),t._v(" "),a("li",[t._v("리마인드 libft 코드 구현.\n"),a("br")])]),t._v(" "),a("h2",{attrs:{id:"_4-동료-학습-방법"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-동료-학습-방법"}},[t._v("#")]),t._v(" 4. 동료 학습 방법")]),t._v(" "),a("ul",[a("li",[t._v("해당사항 없음.\n"),a("br")])]),t._v(" "),a("h2",{attrs:{id:"_5-학습-목표"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-학습-목표"}},[t._v("#")]),t._v(" 5. 학습 목표")]),t._v(" "),a("ul",[a("li",[t._v("지금까지 만들었던 함수들의 내용과 고려해야하는 것들, 구현 방법 등에 대해 다시 정리를 하여 코딩에 대한 이해도를 높임.\n"),a("br")])]),t._v(" "),a("h2",{attrs:{id:"_6-상세-학습-내용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-상세-학습-내용"}},[t._v("#")]),t._v(" 6. 상세 학습 내용")]),t._v(" "),a("blockquote",[a("p",[t._v("실제 코딩 시간 : 총 2시간.")])]),t._v(" "),a("ul",[a("li",[t._v("type_t\n"),a("ul",[a("li",[t._v("stddef.h 에 있음.")]),t._v(" "),a("li",[t._v("unistd.h 에서 stddef.h 를 참조 수행하므로, unistd.h 헤더만 있으면 type_t 를 사용 할 수 있음.")])])])]),t._v(" "),a("h2",{attrs:{id:"libft-function-정리"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#libft-function-정리"}},[t._v("#")]),t._v(" libft function 정리")]),t._v(" "),a("hr"),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v("\t\t\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ft_memset")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[a("code",[t._v("unsigned int")]),t._v(" 로 형변환 된 "),a("code",[t._v("c")]),t._v(" 를 "),a("code",[t._v("len")]),t._v(" 바이트 만큼 string "),a("code",[t._v("b")]),t._v("에 채웁니다.")]),t._v(" "),a("li",[a("code",[t._v("NULL 종료 문자")]),t._v("를 검사하지 않습니다.")]),t._v(" "),a("li",[t._v("반환값 : 첫번째 매개변수(argument) 즉, "),a("code",[t._v("b")]),t._v(" 를 반환합니다.")])]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v("\t\t\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ft_bzero")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[t._v("string "),a("code",[t._v("b")]),t._v(" 에 "),a("code",[t._v("0")]),t._v(" 을 "),a("code",[t._v("n")]),t._v(" 바이트만큼 채웁니다.")]),t._v(" "),a("li",[t._v("만약 "),a("code",[t._v("n")]),t._v(" 이 "),a("code",[t._v("0")]),t._v(" 이면 아무것도 하지 않습니다.")]),t._v(" "),a("li",[a("code",[t._v("memset(s, 0, len)")]),t._v(" 으로 구현 가능합니다.")])]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v("\t\t\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ft_memcpy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("dst"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("src"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[a("code",[t._v("src")]),t._v(" 를 가르키는 곳 부터  "),a("code",[t._v("n")]),t._v(" 바이트 만큼 "),a("code",[t._v("dst")]),t._v(" 가 가르키는 곳에 복사합니다.")]),t._v(" "),a("li",[a("code",[t._v("NULL 종료 문자")]),t._v("를 검사하지 않습니다.")]),t._v(" "),a("li",[a("code",[t._v("dst")]),t._v(" 와 "),a("code",[t._v("src")]),t._v(" 가 "),a("strong",[t._v("overlap")]),t._v(" 될 때의 동작은 정의 되지 않습니다.")]),t._v(" "),a("li",[a("code",[t._v("n")]),t._v(" 바이트 만큼 복사를 하기 때문에 "),a("code",[t._v("unsigned char *")]),t._v(" 의 새로운 메모리 영역을 위한 포인터를 만들어 "),a("code",[t._v("1바이트")]),t._v("씩 값을 복사하는 것을 기억하세요.")]),t._v(" "),a("li",[t._v("반환값 : The original value of "),a("code",[t._v("dst")])])]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v("\t\t\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ft_memccpy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("dst"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("src"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[a("code",[t._v("memccpy()")]),t._v(" 함수는 "),a("code",[t._v("src")]),t._v(" 문자열에서 "),a("code",[t._v("dst")]),t._v(" 문자열로 "),a("strong",[t._v("바이트")]),t._v(" 를 복사합니다.")]),t._v(" "),a("li",[t._v("반환값\n"),a("ul",[a("li",[a("code",[t._v("문자열 src")]),t._v("에서 "),a("code",[t._v("문자 c")]),t._v(" "),a("strong",[t._v("(unsigned char 로 변환 됨)")]),t._v(" 가 있는 경우,\n"),a("ul",[a("li",[t._v("복사가 중지되고 "),a("code",[t._v("문자열 dst")]),t._v("에 "),a("code",[t._v("c를 복사 후")]),t._v(" 그 다음 바이트에 대한 포인터(dst + i + 1)가 리턴됩니다.")])])]),t._v(" "),a("li",[a("code",[t._v("문자열 src")]),t._v("에서 "),a("code",[t._v("문자 c")]),t._v(" 가 없는경우,\n"),a("ul",[a("li",[t._v("n 바이트 만큼 복사되고, "),a("code",[t._v("NULL")]),t._v(" 포인터를 반환합니다.")])])])])])]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v("\t\t\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ft_memmove")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("dst"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("src"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[a("code",[t._v("memmove()")]),t._v(" 함수는 "),a("code",[t._v("문자열 src")]),t._v("에서 "),a("code",[t._v("문자열 dst")]),t._v("로 "),a("code",[t._v("len 바이트")]),t._v("를 복사합니다.")]),t._v(" "),a("li",[a("code",[t._v("memcpy()")]),t._v(" 와 마찬가지로 "),a("code",[t._v("unsigned char *")]),t._v(" 형변환 해야합니다.\n"),a("ul",[a("li",[t._v("메모리 영역에 값을 넣기 위해서 해주는 작업")])])]),t._v(" "),a("li",[t._v("두 문자열이 겹칠(overlap) 수 있는 경우에도 복사는 항상 "),a("code",[t._v("비파괴적인")]),t._v(" 방식으로 수행됩니다.")]),t._v(" "),a("li",[t._v("그러므로 "),a("code",[t._v("src")]),t._v(" 와 "),a("code",[t._v("dst")]),t._v(" 의 위치에 따라 복사하는 방식이 달라집니다.\n"),a("ul",[a("li",[a("code",[t._v("dst")]),t._v(" 가 "),a("code",[t._v("src")]),t._v(" 보다 먼저 있는 경우, 순방향으로 복사")]),t._v(" "),a("li",[a("code",[t._v("dst")]),t._v(" 가 "),a("code",[t._v("src")]),t._v(" 보다 나중에 있는 경우, 순방향으로 복사하면 overlap 될 수 있으므로 역방향으로 복사")])])])]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v("\t\t\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ft_memchr")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[a("code",[t._v("memchr()")]),t._v(" 함수는 문자열 "),a("code",[t._v("s")]),t._v("에서 "),a("code",[t._v("c")]),t._v(" (부호없는 문자로 변환 됨)의 첫 번째 항목을 찾습니다.")]),t._v(" "),a("li",[t._v("반환 값 : "),a("code",[t._v("memchr()")]),t._v(" 함수는 찾은 바이트에 대한 포인터를 반환하거나 "),a("code",[t._v("n")]),t._v(" 바이트 내에 해당 바이트가 없으면 "),a("code",[t._v("NULL")]),t._v("을 반환합니다.`")])]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v("\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ft_memcmp")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("s1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("s2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[a("code",[t._v("memcmp()")]),t._v(" 함수는 바이트 문자열 s1을 바이트 문자열 s2와 비교합니다.")]),t._v(" "),a("li",[t._v("두 문자열 모두 길이가 n 바이트 인 것으로 간주됩니다.")]),t._v(" "),a("li",[t._v("memcmp () 함수는 두 문자열이 동일하면 0을 반환하고, 그렇지 않으면 처음 두 개의 다른 바이트 간의 차이를 반환합니다 (부호없는 문자 값으로 처리되어"),a("code",[t._v("\\ 200 '이")]),t._v("\\ 0'보다 큼,\n예). 길이가 0 인 문자열은 항상 동일합니다. 이 동작은 C에서 필요하지 않으며 이식 가능한 코드는 반환 된 값의 부호에만 의존해야합니다.\n"),a("br")])]),t._v(" "),a("h2",{attrs:{id:"_7-학습-내용에-대한-개인적인-총평"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-학습-내용에-대한-개인적인-총평"}},[t._v("#")]),t._v(" 7. 학습 내용에 대한 개인적인 총평")]),t._v(" "),a("ul",[a("li",[t._v("한달 가까이 libft를 진행하면서 다시 예전에 만들었던 함수를 보았을 때 새롭게 느껴지는 함수들이 많았다. 그만큼 지금 코딩에 노력을 덜 쏟고 있다고 볼 수 있다. 앞으로 나아가는 방향에 목적지가 보이지 않다보니 추진력을 얻기 힘들때가 많고 무기력해지는 기분이든다. 열심히 잘하자, 이런 말들이 나를 불태워 더욱더 에너지를 고갈시키는 기분도 드는 요즘이다. 학습적으로 빈약한 상태에서 좀더 긍정적인 상황들이 일어날 수 있도록 심심치 않게 나에게 긍정적인 경험을 줄 수 있도록 나를 많이 아껴야겠다.\n"),a("br")])]),t._v(" "),a("h2",{attrs:{id:"_8-다음-학습-계획"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-다음-학습-계획"}},[t._v("#")]),t._v(" 8. 다음 학습 계획")]),t._v(" "),a("ul",[a("li",[t._v("libft 정리.")]),t._v(" "),a("li",[t._v("c 언어 기초 강의 교육.\n"),a("br")])]),t._v(" "),a("h2",{attrs:{id:"_9-참고-링크"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-참고-링크"}},[t._v("#")]),t._v(" 9. 참고 링크")]),t._v(" "),a("blockquote",[a("p",[t._v("man 참조.\n"),a("br")])]),t._v(" "),a("h2",{attrs:{id:"_10-과제제출-repository-주소"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-과제제출-repository-주소"}},[t._v("#")]),t._v(" 10. 과제제출 repository 주소")]),t._v(" "),a("blockquote",[a("p",[t._v("http://git.innovationacademy.kr/inshin/libft")])])])}),[],!1,null,null,null);s.default=_.exports}}]);